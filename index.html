<!doctype html>
<html lang="zh-CN">
<meta charset="utf-8">
<title>批量转 WebP 并打包下载</title>
<body>
  <input type="file" id="file" accept="image/*" multiple>
  <label>
    品质：
    <input type="number" id="q" min="1" max="100" value="90">
  </label>
  <br><br>
  <div id="progress" style="margin-bottom:8px;"></div>
  <pre id="log" style="border:1px solid #ccc; padding:8px; height:500px; overflow:auto;font-size: 20px; display:flex; align-items:center; justify-content:center; text-align:center; color:#999;">
    将图片拖到此处自动压缩
  </pre>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    const fileInput = document.getElementById('file');
    const qInput = document.getElementById('q');
    const progressDiv = document.getElementById('progress');
    const logDiv = document.getElementById('log');

    const fmtSize = n => n > 1024*1024 ? (n/1048576).toFixed(2)+' MB' : (n/1024).toFixed(2)+' KB';

    const resetHint = () => {
      logDiv.textContent = '将图片拖到此处自动压缩';
      logDiv.style.display = 'flex';
      logDiv.style.color = '#999';
      logDiv.style.alignItems = 'center';
      logDiv.style.justifyContent = 'center';
      logDiv.style.textAlign = 'center';
    };

    const startLog = () => {
      logDiv.textContent = '';
      logDiv.style.display = 'block';
      logDiv.style.color = '#000';
      logDiv.style.textAlign = 'left';
    };

    const compressFiles = async (files) => {
      if (!files.length) return alert('请选择图片');
      progressDiv.textContent = '准备开始...';
      startLog();

      const qVal = Math.max(1, Math.min(100, +qInput.value || 90));
      const quality = qVal / 100;
      const zip = new JSZip();
      const fileArr = Array.from(files);

      for (let i = 0; i < fileArr.length; i++) {
        const file = fileArr[i];
        progressDiv.textContent = `压缩中：${i + 1} / ${fileArr.length}`;

        const bitmap = await createImageBitmap(file);
        const canvas = document.createElement('canvas');
        canvas.width = bitmap.width;
        canvas.height = bitmap.height;
        canvas.getContext('2d').drawImage(bitmap, 0, 0);
        bitmap.close();

        const blob = await new Promise(r => canvas.toBlob(r, 'image/webp', quality));
        const arrayBuffer = await blob.arrayBuffer();
        const newName = file.name.replace(/\.[^.]+$/, '.webp');

        if (fileArr.length === 1) {
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = newName;
          a.click();
          URL.revokeObjectURL(a.href);
        } else {
          zip.file(newName, arrayBuffer);
        }

        logDiv.textContent += `${file.name}: ${fmtSize(file.size)} → ${fmtSize(blob.size)}\n`;
        logDiv.scrollTop = logDiv.scrollHeight;
      }

      if (fileArr.length > 1) {
        progressDiv.textContent = '正在打包 ZIP...';
        const zipBlob = await zip.generateAsync({ type: 'blob' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(zipBlob);
        a.download = `Webp压缩-品质${qVal}.zip`;
        a.click();
        URL.revokeObjectURL(a.href);
      }

      progressDiv.textContent = '完成！';
    };

    // 选择文件后自动压缩
    fileInput.addEventListener('change', () => compressFiles(fileInput.files));

    // 拖拽文件到页面自动压缩
    document.body.addEventListener('dragover', e => e.preventDefault());
    document.body.addEventListener('drop', e => {
      e.preventDefault();
      if (e.dataTransfer?.files.length) {
        compressFiles(e.dataTransfer.files);
      }
    });

    // 初始显示提示
    resetHint();
  </script>
</body>
</html>
